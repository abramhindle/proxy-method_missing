#+TITLE: Metaprogramming in JS and Ruby: Javascript Proxy and Ruby Missing Method
#+PROPERTY: header-args:C             :exports both :eval yes :flags -std=c99 -pedantic -Wall -Wextra -ftrapv -ggdb3 :eval yes :results value verbatim
#+PROPERTY: header-args:sh            :exports both :eval yes :results value verbatim
#+PROPERTY: header-args:rb            :exports both :eval yes :results value verbatim
#+PROPERTY: header-args:ruby            :exports both :eval yes :results value verbatim
#+PROPERTY: header-args:js            :exports both :eval yes :results value verbatim
#+PROPERTY: header-args:shell         :exports both :eval yes :results value verbatim

* MetaProgramming in JS and Ruby
** Metaprogramming
   - Programming about Programming
   - Treating programs as data to be processed
   - Macros are an example, generate code for code with code.
   - Code that makes code
   - Code that acts like the language would
   - Code about programming

** Goal for today
   - Allow objects in Javascript and Ruby to handle complex
     messages/method calls to them that might not be defined.
   - Learn about Proxy in Javascript
   - Learn about method_missing in Ruby

** Concepts

   Javascript and Ruby are both OO dynamically typed languages. They
   have many similarities and differences.

   - Object: an object has attributes or properties, it can
     handle method calls or messages sent to it. It often inherits
     methods from a class. Objects know themselves and have identity.
     - Objects represent things and individuals.
     - Objects often have a class.
   - Class: the structure (methods/messages and attributes/properties)
     that acts as factory for objects.
     - Classes create objects.
   - Instance: an object made from a class.
   - Attribute/Property/Instance Variables: a value or variable
     associated with an object, encapsulated by the object.
   - Method: code that is bound to an object that runs in the
     context of the object, accessing its attributes/properties.
   - Method Call / Message: a function called within the context of an
     object, that has access to the object and its attributes.
   - Delegate: an object you delegate to, an object your object has
     and defers operations (methods or messages or methods to)
   - Proxy/Decorate/Wrap/Adapt: programmer slang for something that
     receives messages, does a little more work, and then delegates to
     another object

** Proxy in Javascript :js:

Javascript allows some metaprogramming through Reflect and Proxy.
Proxy allows intercepting and wrapping of method calls.

Good documentation on Proxy is found here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy

The actual specification of Proxy is found here:
https://tc39.es/ecma262/#sec-proxy-objects

Many things you want to do with proxy will require reflection. The
Reflect object is described in the spec here:
https://tc39.es/ecma262/#sec-reflect-object

The Proxy wraps or decorates another object and intercepts calls to
it. You can intercept property accesses, you can intercept property
gets, set, deletions, definitions. You can even intercept playing with
prototypes. You can override has.

*** The proxy handler is poorly documented. :js:

I found most documentation within the spec itself and it was put in
different sections and quite confusing.

Handler is an object with methods that the proxy will call. You can
use an kind of object to be the handler. If the handler is undefined,
the default action will happen.

https://tc39.es/ecma262/#sec-proxy-object-internal-methods-and-internal-slots

    - get
    - set
    - has
    - deleteProperty
    - defineProperty
    - getOwnPropertyDescriptor
    - preventExtensions
    - isExtensible
    - getPrototypeOf
    - setPrototypeOf
    - ownKeys
    - apply
    - construct

*** Example intercept get :js:

We're going to intercept the access of properties in Javascript.

First we need a function to handle the access `handlerGet`. Then we
need to make a structure (called the Handler) that is an object with a
method that addresses the operation we are wrapping. In this case the
operation is `get`.

#+BEGIN_SRC js :exports both
function handlerGet(target, prop, receiver) {
  if (prop in target) {
    return target[prop]; //Reflect.get(...arguments);
  } else {
    return `Prop: ${prop} not found`;
  }
}

function makeHandler() {
	return {
		get: handlerGet
	}
}
var obj = {};
var po = new Proxy(obj,makeHandler());
po.fruit = "durian";
console.log("Fruit:\t",po.fruit);
console.log("Salad:\t",po.salad);
console.log("obj.salad\t",obj.salad);
#+END_SRC

#+RESULTS:
: Fruit:	 durian
: Salad:	 Prop: salad not found
: obj.salad	 undefined
: undefined

Let's be honest, why are you returning a string on a miss?

*** Default Return Value

#+BEGIN_SRC js :exports both
function makeHandler( defaultValue = false ) {
  return {
    get: function(target, prop, receiver) {
      if (prop in target) {
        return target[prop]; //Reflect.get(...arguments);
      } else {
        return defaultValue;
      }
    }
  }
}
var obj = {};
var po = new Proxy(obj,makeHandler());
po.fruit = "durian";
console.log("Fruit:\t",po.fruit);
console.log("Salad:\t",po.salad);
console.log("obj.salad\t",obj.salad);
#+END_SRC

#+RESULTS:
: durian
: false
: undefined

*** Autovivify 

In perl if you access chains of objects it can create objects along the way.

#+BEGIN_SRC js :exports both
function makeHandler( defaultValue = false ) {
  return {
    get: function(target, prop, receiver) {
      if (!(prop in target)) {
        target[prop] = defaultValue;
      }
      return target[prop]; //Reflect.get(...arguments);

    }
  }
}
obj = {};
po = new Proxy(obj,makeHandler());
po.fruit = "durian";
console.log("Fruit:\t",po.fruit);
console.log("Salad:\t",po.salad);
console.log("obj.salad\t",obj.salad);
#+END_SRC

#+RESULTS:
: Fruit:	 durian
: Salad:	 false
: obj.salad	 false
: undefined

*** Autovivify Perl Style

In perl if you access chains of objects it can create objects along the way.

#+BEGIN_SRC js :exports both
function makeVivifyHandler() {
  return {
    get: function(target, prop, receiver) {
      if (!(prop in target)) {
        target[prop] = new Proxy({},makeVivifyHandler());
      }
      return target[prop]; //Reflect.get(...arguments);
    }
  }
}
var obj = {};
var po = new Proxy(obj,makeVivifyHandler());
po.fruit = "durian";
console.log("Fruit:\t",po.fruit);
console.log("Salad:\t",po.salad);
console.log("obj.salad\t",obj.salad);
console.log("obj\t",obj);
console.log("obj.salad.what\t",obj.salad.what);
console.log("obj\t",obj);
console.log("po.salad.what\t",po.salad.what);
console.log("obj\t",obj);
console.log("po.salad.what.huh.zuh\t", po.salad.what.huh.zuh);
console.log("obj\t",obj);
console.log("salad" in po);
console.log("dessert" in po);
#+END_SRC

#+RESULTS:
#+begin_example
Fruit:	 durian
Salad:	 {}
obj.salad	 {}
obj	 { fruit: 'durian', salad: {} }
obj.salad.what	 {}
obj	 { fruit: 'durian', salad: { what: {} } }
po.salad.what	 {}
obj	 { fruit: 'durian', salad: { what: {} } }
po.salad.what.huh.zuh	 {}
obj	 { fruit: 'durian', salad: { what: { huh: [Object] } } }
true
false
undefined
#+end_example

*** Proxy Summary

You can use Proxy in Javascript to decorate other objects in order to intercept calls.

You NEED to wrap those objects with Proxy for it to work.


** Ruby Missing Method

When you call a method, if the method does not exist in the current
object's class or it's superclasses then method_missing is called and
handled by the lowest level class to handle it.

The block, the method arguments and the method's name (`method_name`)
(as a symbol) will be passed to the method method_missing.

This is not a decorator, this is a method that is called on the object
when is there is no method to be called for `method_name`

#+BEGIN_SRC ruby :eval no :exports code :session x
  def method_missing(method_name, *method_arguments, &block)
    nil
  end
#+END_SRC

*** Example of method missing responding to missing methods

#+BEGIN_SRC ruby :exports both :session x
class Example
  def initialize()
  end
  def method_missing(m, *args, &block)
    @last_call = [:method_missing, m, *args, block]
  end
end
example = Example.new()
lc1 = example.eat("Pie")
lc2 = example.block(:Arg1) { |x|  x }
{:lc1=>lc1,:lc2=>lc2}
#+END_SRC

#+RESULTS:
: {:lc1=>[:method_missing, :eat, "Pie", nil], :lc2=>[:method_missing, :block, :Arg1, #<Proc:0x0000563dee559df8 (irb):84>]}

*** Delegation is easy

#+BEGIN_SRC ruby :exports both :session x
Object.send(:remove_const,:Dog) # Make sure there's no Dog class
class Dog
  def initialize()
  end
  def speak()
    "Ruff"
  end
  def legs()
    4
  end
end
#+END_SRC

#+RESULTS:
: :legs

#+BEGIN_SRC ruby :exports both :session x
Object.send(:remove_const,:Cat) # Make sure there's no Cat class
class Cat
  def initialize()
    @delegate = Dog.new()
  end
  def method_missing(m, *args, &block)
    @delegate.send(m, *args, &block)
  end
end
#+END_SRC

#+RESULTS:
: :method_missing

#+BEGIN_SRC ruby :exports both :session x
cat = Cat.new()
cat.speak()
#+END_SRC

#+RESULTS:
: Ruff

#+BEGIN_SRC ruby :exports both :session x
class Cat
  def speak
     "meow"
  end
end
cat = Cat.new()
[cat.speak(), cat.legs()]
#+END_SRC

#+RESULTS:
: ["meow", 5]

#+BEGIN_SRC ruby :exports both :session x
cat = Cat.new()
cat.consume_the_sun()
#+END_SRC

#+RESULTS:
: #<NoMethodError: undefined method `consume_the_sun' for #<Dog:0x0000563dee4f5a88>>


** Copyright Statement

Code is (c) 2021 Abram Hindle. 

Unless stated otherwise, assume Python license, or Ruby license
depending on the example.

** Init ORG-MODE

#+BEGIN_SRC elisp
;; I need this for org-mode to work well
;; If we have a new org-mode use ob-shell
;; otherwise use ob-sh --- but not both!
;;(require 'ob-ruby)
;;(require 'inf-ruby)
;;(require 'enh-ruby-mode)

(if (require 'ob-shell nil 'noerror)
  (progn
    (org-babel-do-load-languages 'org-babel-load-languages '((shell . t))))
  (progn
    (require 'ob-sh)
    (org-babel-do-load-languages 'org-babel-load-languages '((sh . t)))))
(org-babel-do-load-languages 'org-babel-load-languages '((C . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((ruby . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((js . t)))
(org-babel-do-load-languages 'org-babel-load-languages '((python . t)))
(setq org-babel-js-function-wrapper
      "process.stdout.write(require('util').inspect(function(){\n%s\n}(), { maxArrayLength: null, maxStringLength: null, breakLength: Infinity, compact: true }))")
(setq org-src-fontify-natively t)
(setq org-confirm-babel-evaluate nil) ;; danger!
(custom-set-faces
 '(org-block ((t (:inherit shadow :foreground "black"))))
 '(org-code ((t (:inherit shadow :foreground "black")))))
;(setq inf-ruby-default-implementation "ruby")
#+END_SRC

#+RESULTS:

*** Org export
#+BEGIN_SRC elisp
(org-html-export-to-html)
(org-latex-export-to-pdf)
(org-ascii-export-to-ascii)
#+END_SRC

#+RESULTS:
: presentation.txt


*** Org Template
Copy and paste this to demo C

#+BEGIN_SRC C :exports both
#include <stdio.h>

int main(int argc, char**argv) {
    return 0;
}
#+END_SRC

#+RESULTS:

#+BEGIN_SRC js :exports both
var util = require("util");
console.log("this is a Node.js test program!");
console.log("this is a Node.js test program! again");
#+END_SRC

#+RESULTS:
: this is a Node.js test program!
: this is a Node.js test program! again
: undefined

#+BEGIN_SRC ruby :exports both
[12,"ruby"]
#+END_SRC

#+RESULTS:
: [12, "ruby"]

#+BEGIN_SRC ruby :exports both :session x
class XYZ
end
XYZ.new()
#+END_SRC

#+RESULTS:
: #<XYZ:0x0000563dee304418>
